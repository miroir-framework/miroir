{
  "uuid": "9cdc1af9-13d6-4477-8482-8af43e3c161e",
  "selfApplication": "21840247-b5b1-4344-baec-f818f4797d92",
  "parentName": "Report",
  "parentUuid": "3f2baa83-3ef7-45ce-82ea-6a43f7a8c916",
  "conceptLevel": "Model",
  "name": "_MiroirDocumentation",
  "defaultLabel": "Documentation of Miroir",
  "definition": {
    "section": {
      "type": "list",
      "definition": [
        {
          "type": "markdownReportSection",
          "definition": {
            "label": "Transformers",
            "content": "# Transformers\n\n![an image](https://en.wikipedia.org/static/images/icons/wikipedia.png)\n\n![an other image](/assets/images/logo.png)\n\nTransformers are pure functions that transform data. They can run in-memory on the client or server, or be executed in the database (PostgreSQL). Each transformer is defined with a specific input and output type.\n\n## Constant Value Transformers\n\nThese transformers return constant values without requiring input.\n\n- **constant**: Returns any constant value provided in the configuration\n- **newUuid**: Generates a new UUID v4 identifier\n\n## Reference and Context Transformers\n\nThese transformers access values from the runtime context or parameters.\n\n- **contextReference**: Retrieves a value from the runtime context using a key or path\n- **parameterReference**: Retrieves a value from the build parameters using a key or path\n- **constantAsExtractor**: Returns a constant value formatted as an extractor result (used primarily for testing)\n\n## String Template Transformers\n\nThese transformers work with string templates and interpolation.\n\n- **mustacheStringTemplate**: Processes a mustache template string with variable substitution (e.g., `\"Hello {{name}}\"`)\n\n## List Transformers\n\nThese transformers operate on arrays to filter, transform, or aggregate data.\n\n- **mapperListToList**: Transforms each element in a list by applying a transformer to every item\n- **listPickElement**: Extracts a specific element from a list based on criteria\n- **unique**: Removes duplicate values from a list, returning only unique elements\n- **count**: Aggregates a list into a count object, optionally grouping by an attribute\n- **listReducerToIndexObject**: Converts a list into an indexed object (similar to a dictionary)\n- **listReducerToSpreadObject**: Converts a list of objects into a single spread object\n\n## Object Transformers\n\nThese transformers manipulate objects and their properties.\n\n- **objectValues**: Extracts all values from an object into an array\n- **objectEntries**: Converts an object into an array of key-value pairs\n- **objectDynamicAccess**: Accesses nested properties in an object using a dynamic path (transitive access)\n- **freeObjectTemplate**: Creates an object from a record of key-transformer pairs, where each key maps to a transformer\n- **object_fullTemplate**: Creates an object from an array of key-value pairs with advanced templating\n- **dataflowObject**: Creates a spread object by applying transformers in a dataflow pattern\n\n## Control Flow Transformers\n\nThese transformers handle conditional logic and branching.\n\n- **conditional**: Returns different transformer results based on comparing values using operators (==, !=, <, <=, >, >=)\n\n## Schema and Type Transformers (MLS)\n\nThese transformers work with the Miroir Meta-Language (Jzod schemas) and cannot run as SQL.\n\n- **jzodTypeCheck**: Validates whether a value matches a given Jzod schema definition\n- **resolveSchemaReferenceInContext**: Resolves schema references within a context to get the actual schema definition\n- **resolveConditionalSchema**: Infers the concrete Jzod schema from a conditional schema declaration and a value object\n- **unfoldSchemaOnce**: Unfolds a Jzod schema by one level, resolving immediate schema references\n- **defaultValueForSchema**: Generates a default value object that conforms to a given Jzod schema\n\n## Tips for Using Transformers\n\n- **Composition**: Transformers can be chained together - the output of one becomes the input of another\n- **Context Access**: Use `contextReference` and `parameterReference` to access runtime values\n- **Lists**: Use `mapperListToList` to transform each element, then `unique` or `count` to aggregate\n- **Objects**: Combine `objectValues` or `objectEntries` with list transformers to process object data\n- **Conditionals**: Use the `conditional` transformer for if-then-else logic in your data transformations\n- **Schema Operations**: MLS transformers are powerful for meta-programming but cannot be executed in SQL\n"
          }
        }
      ]
    }
  }
}