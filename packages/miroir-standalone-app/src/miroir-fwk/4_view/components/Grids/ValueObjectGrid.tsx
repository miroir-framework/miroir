import {
  CellClickedEvent,
  CellValueChangedEvent,
  ColDef,
  ColGroupDef,
  GridApi
} from 'ag-grid-community';
import { AgGridReact } from 'ag-grid-react';
import { useCallback, useMemo, useState, useRef, useEffect } from "react";

import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-alpine.css';

import {
  JzodElement,
  JzodObject,
  LoggerInterface,
  MiroirLoggerFactory,
} from "miroir-core";

import { packageName } from '../../../../constants.js';
import EntityEditor from '../../EntityEditor.js';
import { cleanLevel } from '../../constants.js';
import { calculateAdaptiveColumnWidths, ToolsColumnDefinition } from '../../adaptiveColumnWidths.js';
import { ToolsCellRenderer } from './GenderCellRenderer.js';
import { GlideDataGridComponent } from './GlideDataGridComponent.js';
import { JsonObjectDeleteFormDialog } from '../JsonObjectDeleteFormDialog.js';
import {
  JsonObjectEditFormDialog,
  JsonObjectEditFormDialogInputs,
} from "../JsonObjectEditFormDialog.js";
import {
  ValueObjectGridProps,
  ValueObjectGridRow,
  AutoGeneratedColumnDef,
} from "./ValueObjectGridInterface.js";
import { useMiroirTableTheme } from '../../contexts/MiroirThemeContext.js';
import { TableTheme, DeepPartial, createTableTheme } from '../../themes/TableTheme.js';
import { generateAgGridStyles, generateGlideTheme, getFilterToolbarStyles } from '../../themes/TableStyleGenerators.js';

// ################################################################################################
let log: LoggerInterface = console as any as LoggerInterface;
MiroirLoggerFactory.registerLoggerToStart(
  MiroirLoggerFactory.getLoggerName(packageName, cleanLevel, "ValueObjectGrid")
).then((logger: LoggerInterface) => {log = logger});

// ################################################################################################
// Auto-generate column definitions from jzodSchema
const generateColumnDefsFromSchema = (jzodSchema: JzodObject): AutoGeneratedColumnDef[] => {
  const columnDefs: AutoGeneratedColumnDef[] = [];
  
  if (jzodSchema.definition) {
    Object.entries(jzodSchema.definition).forEach(([fieldName, fieldSchema]) => {
      const jzodElement = fieldSchema as JzodElement;
      
      let columnType = "string";
      let cellRenderer = undefined;
      
      // Determine column type and renderer based on jzod type
      if (jzodElement.type === "number") {
        columnType = "number";
      } else if (jzodElement.type === "boolean") {
        columnType = "boolean";
      } else if (jzodElement.type === "date") {
        columnType = "date";
      } else if (jzodElement.type === "object") {
        columnType = "object";
        // For objects, we'll stringify them for display
        cellRenderer = "jsonCellRenderer";
      } else if (jzodElement.type === "array") {
        columnType = "array";
        cellRenderer = "jsonCellRenderer";
      }
      
      columnDefs.push({
        field: fieldName,
        headerName: fieldName.charAt(0).toUpperCase() + fieldName.slice(1).replace(/([A-Z])/g, ' $1'),
        type: columnType,
        cellRenderer,
        editable: false, // Value objects are not editable by default
        sortable: true,
        filter: true,
        minWidth: 100,
      });
    });
  }
  
  return columnDefs;
};

// ################################################################################################
// Generate local ID for value objects that don't have UUIDs
const generateLocalId = (obj: any, index: number): string => {
  // Try to use existing identifiers first
  if (obj.uuid) return obj.uuid;
  if (obj.id) return obj.id;
  if (obj.name) return `${obj.name}_${index}`;
  
  // Generate a stable ID based on object content and index
  const objString = typeof obj === 'object' ? JSON.stringify(obj) : String(obj);
  return `row_${index}_${objString.slice(0, 20).replace(/[^a-zA-Z0-9]/g, '_')}`;
};

// ################################################################################################
export const ValueObjectGrid = (props: ValueObjectGridProps & { theme?: DeepPartial<TableTheme> }) => {
  // log.info(":::::::::::::::::::::::::: ValueObjectGrid refreshing with props", props);
  
  // Get theme from context first, then allow prop overrides
  const contextTheme = useMiroirTableTheme();
  
  // Use the unified table theme with optional overrides
  const tableTheme = useMemo(() => {
    return props.theme ? createTableTheme({
      ...contextTheme,
      ...props.theme,
    }) : contextTheme;
  }, [contextTheme, props.theme]);
  
  const filterToolbarStyles = useMemo(() => getFilterToolbarStyles(tableTheme), [tableTheme]);
  const agGridStyles = useMemo(() => generateAgGridStyles(tableTheme), [tableTheme]);
  const glideTheme = useMemo(() => generateGlideTheme(tableTheme), [tableTheme]);
  
  const gridApiRef = useRef<GridApi | null>(null);
  const [hasAnyFilter, setHasAnyFilter] = useState(false);
  
  // Dialog states for editing (only used when editing is enabled)
  const [dialogFormObject, setdialogFormObject] = useState<undefined | any>(undefined);
  const [editDialogFormIsOpen, setEditDialogFormIsOpen] = useState(false);
  const [deleteDialogFormIsOpen, setDeleteDialogFormIsOpen] = useState(false);

  // Container width tracking for adaptive column sizing
  const containerRef = useRef<HTMLDivElement>(null);
  const [containerWidth, setContainerWidth] = useState<number>(1200);

  // ##############################################################################################
  // Auto-generate column definitions from jzodSchema if not provided
  const autoGeneratedColumnDefs = useMemo(() => {
    return generateColumnDefsFromSchema(props.jzodSchema);
  }, [props.jzodSchema]);

  // Use provided columnDefs or auto-generated ones
  const effectiveColumnDefs = useMemo(() => {
    return props.columnDefs?.columnDefs || autoGeneratedColumnDefs;
  }, [props.columnDefs, autoGeneratedColumnDefs]);

  // ##############################################################################################
  // Transform value objects into grid rows (compatible with TableComponentRow)
  const valueObjectGridRows: { valueObjectGridRowSchema: ValueObjectGridRow[] } = useMemo(() => ({
    valueObjectGridRowSchema: (props.valueObjects || [])
      .sort((a: any, b: any) => 
        props.sortByAttribute
          ? (a[props.sortByAttribute] > b[props.sortByAttribute] ? 1 : 
             a[props.sortByAttribute] < b[props.sortByAttribute] ? -1 : 0)
          : 0
      )
      .map((valueObject: any, index: number) => ({
        localId: generateLocalId(valueObject, index),
        rawValue: valueObject,
        jzodSchema: props.jzodSchema.definition || {},
        displayedValue: Object.fromEntries(
          Object.entries(valueObject).map(([key, value]) => {
            const fieldSchema = props.jzodSchema.definition?.[key] as JzodElement;
            return [
              key,
              fieldSchema?.type === "object" || fieldSchema?.type === "array"
                ? JSON.stringify(value)
                : value,
            ];
          })
        ),
      })),
  }), [props.valueObjects, props.sortByAttribute, props.jzodSchema]);

  // Convert to TableComponentRow format for compatibility with GlideDataGridComponent
  const tableComponentRows: { tableComponentRowUuidIndexSchema: any[] } = useMemo(() => ({
    tableComponentRowUuidIndexSchema: valueObjectGridRows.valueObjectGridRowSchema.map(row => ({
      deploymentUuid: "", // Not needed for value objects
      rawValue: row.rawValue,
      jzodSchema: row.jzodSchema,
      foreignKeyObjects: {}, // Not needed for value objects
      displayedValue: row.displayedValue,
      localId: row.localId, // Keep localId for our own reference
    }))
  }), [valueObjectGridRows]);

  // ##############################################################################################
  // Grid event handlers
  const onGridReady = useCallback((params: any) => {
    gridApiRef.current = params.api;
    
    // Add custom filter handling similar to EntityInstanceGrid
    setTimeout(() => {
      const updateFilterUI = () => {
        const filterModel = gridApiRef.current?.getFilterModel();
        const hasAnyFilterActive = filterModel && Object.keys(filterModel).length > 0;
        setHasAnyFilter(!!hasAnyFilterActive);
      };
      
      updateFilterUI();
      
      if (gridApiRef.current) {
        gridApiRef.current.addEventListener('filterChanged', () => {
          setTimeout(updateFilterUI, 50);
        });
      }
    }, 100);
  }, []);

  const handleGlobalClearAllFilters = useCallback(() => {
    if (gridApiRef.current) {
      gridApiRef.current.setFilterModel(null);
      // log.info('All filters cleared in ValueObjectGrid');
    }
  }, []);

  // ##############################################################################################
  // Handle cell value changes (for display only, no actual editing)
  const onCellValueChanged = useCallback(async (event: CellValueChangedEvent) => {
    log.warn("onCellValueChanged in ValueObjectGrid - value objects are read-only", event);
  }, []);

  // ##############################################################################################
  // Handle cell clicks (no navigation for value objects)
  const onCellClicked = useCallback((event: CellClickedEvent) => {
    // log.info("ValueObjectGrid cell clicked", event.colDef.field, event.data);
    // Value objects don't have navigation behavior
  }, []);

  // ##############################################################################################
  // Dialog handlers (only used when editing is enabled via props)
  const handleEditDialogFormOpen = useCallback((row?: ValueObjectGridRow, event?: any) => {
    if (!props.onRowEdit) return;
    
    // log.info('handleEditDialogFormOpen called with row', row);
    if (row) {
      setdialogFormObject(row.rawValue);
    } else {
      setdialogFormObject(undefined);
    }
    setEditDialogFormIsOpen(true);
  }, [props.onRowEdit]);

  const handleEditDialogFormClose = useCallback((value?: string, event?: any) => {
    // log.info('handleEditDialogFormClose', value);
    setEditDialogFormIsOpen(false);
  }, []);

  const handleDeleteDialogFormOpen = useCallback((row?: ValueObjectGridRow, event?: any) => {
    if (!props.onRowDelete) return;
    
    // log.info('handleDeleteDialogFormOpen called with row', row);
    if (row) {
      setdialogFormObject(row.rawValue);
    } else {
      setdialogFormObject(undefined);
    }
    setDeleteDialogFormIsOpen(true);
  }, [props.onRowDelete]);

  const handleDuplicateDialogFormOpen = useCallback((row?: ValueObjectGridRow, event?: any) => {
    if (!props.onRowDuplicate) return;
    
    // log.info('handleDuplicateDialogFormOpen called with row', row);
    if (row) {
      // Create a duplicate
      const duplicatedObject = { ...row.rawValue };
      setdialogFormObject(duplicatedObject);
    } else {
      setdialogFormObject(undefined);
    }
    setEditDialogFormIsOpen(true);
  }, [props.onRowDuplicate]);

  const onEditDialogFormSubmit = useCallback(async (data: JsonObjectEditFormDialogInputs) => {
    // log.info('onEditDialogFormSubmit called with data', data);
    if (props.onRowEdit) {
      await props.onRowEdit(data);
    }
    handleEditDialogFormClose('');
  }, [props.onRowEdit]);

  const onDeleteDialogFormSubmit = useCallback(async (data: JsonObjectEditFormDialogInputs) => {
    // log.info('onDeleteDialogFormSubmit called with data', data);
    if (props.onRowDelete) {
      await props.onRowDelete(data);
    }
    handleEditDialogFormClose('');
  }, [props.onRowDelete]);

  // ##############################################################################################
  // Container width tracking
  useEffect(() => {
    let updateTimer: NodeJS.Timeout;
    
    const updateWidth = () => {
      if (containerRef.current) {
        const width = containerRef.current.clientWidth;
        if (width > 0 && Math.abs(width - containerWidth) > 10) {
          setContainerWidth(width);
          log.debug("ValueObjectGrid container width updated:", width);
        }
      }
    };

    const debouncedUpdateWidth = () => {
      clearTimeout(updateTimer);
      updateTimer = setTimeout(updateWidth, 150);
    };

    const initialTimer = setTimeout(updateWidth, 100);

    let resizeObserver: ResizeObserver | undefined;
    
    if (containerRef.current && 'ResizeObserver' in window) {
      resizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          const width = entry.contentRect.width;
          if (width > 0 && Math.abs(width - containerWidth) > 10) {
            debouncedUpdateWidth();
          }
        }
      });
      
      resizeObserver.observe(containerRef.current);
    }

    window.addEventListener('resize', debouncedUpdateWidth);
    
    return () => {
      clearTimeout(initialTimer);
      clearTimeout(updateTimer);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      window.removeEventListener('resize', debouncedUpdateWidth);
    };
  }, [containerWidth]);

  // ##############################################################################################
  // Default column definition
  const defaultColDef: ColDef | ColGroupDef = useMemo(() => ({
    editable: false, // Value objects are read-only
    sortable: true,
    filter: true,
    resizable: true,
    floatingFilter: false,
    minWidth: 100,
    filterParams: {
      filterOptions: ['contains', 'startsWith', 'endsWith', 'equals', 'notEqual'],
      defaultOption: 'contains',
      suppressAndOrCondition: false,
      trimInput: true,
      debounceMs: 300,
    },
  }), []);

  // Define tools column configuration
  const toolsColumnDefinition: ToolsColumnDefinition = useMemo(() => ({
    field: "",
    headerName: "Actions", 
    width: 120
  }), []);

  // ##############################################################################################
  // Calculate adaptive column widths
  const calculatedColumnWidths = useMemo(() => {
    const rowCount = tableComponentRows.tableComponentRowUuidIndexSchema.length;
    const needsVerticalScrollbar = rowCount > 15;
    const scrollbarWidth = needsVerticalScrollbar ? 17 : 0;
    const borderWidth = 2;
    
    const stableWidth = Math.min(Math.max(containerWidth - scrollbarWidth - borderWidth, 300), 1800);
    
    const widthSpecs = calculateAdaptiveColumnWidths(
      effectiveColumnDefs,
      tableComponentRows.tableComponentRowUuidIndexSchema,
      stableWidth,
      toolsColumnDefinition, // Always pass it, even if tools are not displayed
      props.jzodSchema.definition,
    );
    
    // log.info("ValueObjectGrid calculated column widths", {
    //   containerWidth,
    //   stableWidth,
    //   rowCount,
    //   totalCalculatedWidth: widthSpecs.reduce((sum, spec) => sum + spec.calculatedWidth, 0),
    // });
    
    return widthSpecs;
  }, [effectiveColumnDefs, tableComponentRows, containerWidth, props.displayTools, toolsColumnDefinition, props.jzodSchema]);

  // ##############################################################################################
  // Build column definitions with tools column if needed
  const columnDefs: (ColDef | ColGroupDef)[] = useMemo(() => {
    const baseColumnDefs = [];
    
    // Add tools column if editing is enabled
    if (props.displayTools && (props.onRowEdit || props.onRowDelete || props.onRowDuplicate)) {
      baseColumnDefs.push({
        field: toolsColumnDefinition.field,
        headerName: toolsColumnDefinition.headerName,
        cellRenderer: ToolsCellRenderer,
        editable: false,
        sortable: false,
        filter: false,
        resizable: false,
        width: toolsColumnDefinition.width,
        cellRendererParams: {
          onClickEdit: props.onRowEdit ? handleEditDialogFormOpen : undefined,
          onClickDuplicate: props.onRowDuplicate ? handleDuplicateDialogFormOpen : undefined,
          onClickDelete: props.onRowDelete ? handleDeleteDialogFormOpen : undefined,
        },
      });
    }

    // Add data columns
    const dataColumns = effectiveColumnDefs.map((colDef: any) => ({
      ...colDef,
      valueGetter: (params: any) => {
        if (!params.data || !colDef.field) return "";
        return params.data.displayedValue?.[colDef.field] ?? params.data.rawValue?.[colDef.field] ?? "";
      },
      filterValueGetter: (params: any) => {
        if (!params.data || !colDef.field) return "";
        return params.data.displayedValue?.[colDef.field] ?? params.data.rawValue?.[colDef.field] ?? "";
      },
      filter: true,
      filterParams: {
        filterOptions: ["contains", "startsWith", "endsWith", "equals", "notEqual"],
        defaultOption: "contains",
        suppressAndOrCondition: false,
      },
    }));

    const allColumns = [...baseColumnDefs, ...dataColumns];

    // Apply adaptive widths if calculated
    if (calculatedColumnWidths) {
      allColumns.forEach((colDef: any, index) => {
        let widthSpec;
        if (index === 0 && props.displayTools) {
          // Tools column
          widthSpec = calculatedColumnWidths.find((spec) => spec.type === "tools");
        } else {
          // Data columns
          const dataIndex = props.displayTools ? index - 1 : index;
          const dataColDef = effectiveColumnDefs[dataIndex];
          widthSpec = calculatedColumnWidths.find((spec) => spec.field === dataColDef?.field);
        }
        
        if (widthSpec) {
          colDef.width = Math.round(widthSpec.calculatedWidth);
          colDef.minWidth = Math.round(widthSpec.minWidth);
          colDef.maxWidth = Math.round(widthSpec.maxWidth);
          colDef.suppressSizeToFit = true;
          colDef.suppressAutoSize = true;
        }
      });
    }

    return allColumns;
  }, [
    effectiveColumnDefs,
    props.displayTools,
    props.onRowEdit,
    props.onRowDelete,
    props.onRowDuplicate,
    handleEditDialogFormOpen,
    handleDuplicateDialogFormOpen,
    handleDeleteDialogFormOpen,
    calculatedColumnWidths,
    toolsColumnDefinition,
  ]);

  // ##############################################################################################
  // Glide grid cell click handler
  const onGlideGridCellClicked = useCallback((cell: any, event: any) => {
    const [col, row] = cell;
    const rowData = tableComponentRows.tableComponentRowUuidIndexSchema[row];
    // log.info("ValueObjectGrid Glide cell clicked", { col, row, rowData });
    // No navigation for value objects
  }, [tableComponentRows]);

  // Wrapper handlers to convert between TableComponentRow and ValueObjectGridRow
  const handleGlideEditDialogFormOpen = useCallback((row: any, event?: any) => {
    if (!props.onRowEdit) return;
    // Find the original ValueObjectGridRow
    const originalRow = valueObjectGridRows.valueObjectGridRowSchema.find(
      vRow => vRow.localId === (row as any).localId
    );
    if (originalRow) {
      handleEditDialogFormOpen(originalRow, event);
    }
  }, [props.onRowEdit, handleEditDialogFormOpen, valueObjectGridRows]);

  const handleGlideDeleteDialogFormOpen = useCallback((row: any, event?: any) => {
    if (!props.onRowDelete) return;
    const originalRow = valueObjectGridRows.valueObjectGridRowSchema.find(
      vRow => vRow.localId === (row as any).localId
    );
    if (originalRow) {
      handleDeleteDialogFormOpen(originalRow, event);
    }
  }, [props.onRowDelete, handleDeleteDialogFormOpen, valueObjectGridRows]);

  const handleGlideDuplicateDialogFormOpen = useCallback((row: any, event?: any) => {
    if (!props.onRowDuplicate) return;
    const originalRow = valueObjectGridRows.valueObjectGridRowSchema.find(
      vRow => vRow.localId === (row as any).localId
    );
    if (originalRow) {
      handleDuplicateDialogFormOpen(originalRow, event);
    }
  }, [props.onRowDuplicate, handleDuplicateDialogFormOpen, valueObjectGridRows]);

  // ##############################################################################################
  return (
    <div 
      ref={containerRef}
      style={{ 
        width: '100%', 
        maxWidth: '100%', 
        overflow: 'hidden', 
        boxSizing: 'border-box',
        fontFamily: tableTheme.typography.fontFamily,
        position: 'relative',
        zIndex: 1,
      }}
    >
      {/* Apply unified table styles */}
      <style>{agGridStyles}</style>
      
      {/* Global Clear All Filters Icon */}
      {hasAnyFilter && (
        <div style={filterToolbarStyles.container}>
          <span
            className="mtable-global-clear-filters"
            onClick={handleGlobalClearAllFilters}
            style={filterToolbarStyles.clearAllButton}
            title="Clear all filters"
          >
            ▼ Clear All Filters
          </span>
        </div>
      )}

      {/* Edit/Delete dialogs (only rendered if editing is enabled) */}
      {dialogFormObject && (props.onRowEdit || props.onRowDelete) ? (
        <>
          <JsonObjectEditFormDialog
            showButton={false}
            isOpen={editDialogFormIsOpen}
            isAttributes={true}
            label="Value Object"
            defaultFormValuesObject={dialogFormObject}
            entityDefinitionJzodSchema={props.jzodSchema}
            foreignKeyObjects={{}}
            currentDeploymentUuid=""
            currentApplicationSection="data"
            currentAppModel={{} as any}
            currentMiroirModel={{} as any}
            addObjectdialogFormIsOpen={false}
            setAddObjectdialogFormIsOpen={() => {}}
            onSubmit={onEditDialogFormSubmit}
            onClose={handleEditDialogFormClose}
          />
          <JsonObjectDeleteFormDialog
            showButton={false}
            currentDeploymentUuid=""
            currentApplicationSection="data"
            currentAppModel={{} as any}
            currentMiroirModel={{} as any}
            defaultFormValuesObject={dialogFormObject}
            deleteObjectdialogFormIsOpen={deleteDialogFormIsOpen}
            entityDefinitionJzodSchema={props.jzodSchema}
            foreignKeyObjects={{}}
            isOpen={deleteDialogFormIsOpen}
            isAttributes={true}
            label="Value Object"
            onDeleteFormObject={onDeleteDialogFormSubmit}
            onClose={handleEditDialogFormClose}
            setDeleteObjectdialogFormIsOpen={setDeleteDialogFormIsOpen}
          />
        </>
      ) : (
        <></>
      )}

      {/* Grid implementation */}
      {props.gridType === "ag-grid" ? (
        <div
          id="valueObjectGrid"
          className="ag-theme-alpine"
          style={{
            ...(tableComponentRows.tableComponentRowUuidIndexSchema.length > 50
              ? { 
                  ...props.styles, 
                  height: "50vh", 
                  maxHeight: tableTheme.components.table.maxHeight 
                }
              : {
                  ...props.styles,
                  minHeight: tableTheme.components.table.minHeight
                }),
            width: '100%',
            maxWidth: '100%',
            overflow: 'auto',
            boxSizing: 'border-box',
            borderRadius: tableTheme.components.table.borderRadius,
            border: tableTheme.components.table.border,
          }}
        >
          <AgGridReact
            domLayout={
              tableComponentRows.tableComponentRowUuidIndexSchema.length > 50
                ? "normal"
                : "autoHeight"
            }
            columnDefs={columnDefs}
            rowData={tableComponentRows.tableComponentRowUuidIndexSchema}
            getRowId={(params) => {
              return params.data?.localId || params.data?.rawValue?.uuid || Math.random().toString();
            }}
            defaultColDef={defaultColDef}
            onCellClicked={onCellClicked}
            onCellValueChanged={onCellValueChanged}
            onGridReady={onGridReady}
            // enableRangeSelection={true}
            enableCellTextSelection={true}
            suppressRowClickSelection={true}
            animateRows={true}
            skipHeaderOnAutoSize={true}
            suppressHorizontalScroll={false}
          />
        </div>
      ) : (
        <GlideDataGridComponent
          tableComponentRows={tableComponentRows}
          columnDefs={{ columnDefs: effectiveColumnDefs }}
          styles={{
            ...props.styles,
            fontFamily: tableTheme.typography.fontFamily,
            fontSize: tableTheme.typography.fontSize,
            borderRadius: tableTheme.components.table.borderRadius,
            border: tableTheme.components.table.border,
          }}
          type="JSON_ARRAY"
          calculatedColumnWidths={calculatedColumnWidths}
          containerWidth={containerWidth}
          toolsColumnDefinition={toolsColumnDefinition}
          maxRows={props.maxRows}
          theme={tableTheme}
          glideTheme={glideTheme}
          onCellClicked={onGlideGridCellClicked}
          onCellEdited={(cell, newValue) => {
            log.info("ValueObjectGrid Glide cell edited (read-only)", cell, newValue);
          }}
          onRowEdit={props.onRowEdit ? handleGlideEditDialogFormOpen : undefined}
          onRowDelete={props.onRowDelete ? handleGlideDeleteDialogFormOpen : undefined}
          onRowDuplicate={props.onRowDuplicate ? handleGlideDuplicateDialogFormOpen : undefined}
        />
      )}
    </div>
  );
};
