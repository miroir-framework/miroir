import {
  CellClickedEvent,
  CellValueChangedEvent,
  ColDef,
  ColGroupDef,
  GridApi,
} from "ag-grid-community";
import { AgGridReact } from "ag-grid-react";
import { useCallback, useMemo, useRef, useState, type FC } from "react";

import "ag-grid-community/styles/ag-grid.css";
import "ag-grid-community/styles/ag-theme-alpine.css";

import { JzodElement, JzodObject, LoggerInterface, MiroirLoggerFactory } from "miroir-core";

import { useMiroirContextService } from "miroir-react";
import { packageName } from "../../../../constants.js";
import {
  ToolsColumnDefinition
} from "../../adaptiveColumnWidths.js";
import { cleanLevel } from "../../constants.js";
import { useMiroirTableTheme } from "../../contexts/MiroirThemeContext.js";
import { RenderPerformanceMetrics } from "../../tools/renderPerformanceMeasure.js";
import {
  JsonObjectEditFormDialogInputs
} from "../JsonObjectEditFormDialog.js";
import {
  generateAgGridStyles,
  generateGlideTheme,
  getFilterToolbarStyles,
} from "../Themes/TableStyleGenerators.js";
import { DeepPartial, TableTheme } from "../Themes/TableTheme.js";
import { ToolsCellRenderer } from "./GenderCellRenderer.js";
import { GlideDataGridComponent } from "./GlideDataGridComponent.js";
import { defaultColDef } from "./GridTools.js";
import {
  AutoGeneratedColumnDef,
  ValueObjectGridProps,
  ValueObjectGridRow,
} from "./ValueObjectGridInterface.js";

// ################################################################################################
let log: LoggerInterface = console as any as LoggerInterface;
MiroirLoggerFactory.registerLoggerToStart(
  MiroirLoggerFactory.getLoggerName(packageName, cleanLevel, "ValueObjectGrid"),
  "UI"
).then((logger: LoggerInterface) => {
  log = logger;
});

// ################################################################################################
// Auto-generate column definitions from mlSchema
const generateColumnDefsFromSchema = (mlSchema: JzodObject): AutoGeneratedColumnDef[] => {
  const columnDefs: AutoGeneratedColumnDef[] = [];

  if (mlSchema.definition) {
    Object.entries(mlSchema.definition).forEach(([fieldName, fieldSchema]) => {
      const jzodElement = fieldSchema as JzodElement;

      let columnType: AutoGeneratedColumnDef["type"] = "text";
      let cellRenderer = undefined;

      // Determine column type and renderer based on jzod type
      if (jzodElement.type === "number") {
        columnType = "number";
      } else if (jzodElement.type === "boolean") {
        columnType = "boolean";
      } else if (jzodElement.type === "date") {
        columnType = "date";
      } else if (jzodElement.type === "object") {
        columnType = "object";
        // For objects, we'll stringify them for display
        cellRenderer = "jsonCellRenderer";
      } else if (jzodElement.type === "array") {
        columnType = "array";
        cellRenderer = "jsonCellRenderer";
      }

      columnDefs.push({
        type: columnType,
        field: fieldName,
        headerName:
          fieldName.charAt(0).toUpperCase() + fieldName.slice(1).replace(/([A-Z])/g, " $1"),
        cellRenderer,
        editable: false, // Value objects are not editable by default
        sortable: true,
        filter: true,
        minWidth: 100,
      });
    });
  }

  return columnDefs;
};

// ################################################################################################
// Generate local ID for value objects that don't have UUIDs
const generateLocalId = (obj: any, index: number): string => {
  // Try to use existing identifiers first
  if (obj.uuid) return obj.uuid;
  if (obj.id) return obj.id;
  if (obj.name) return `${obj.name}_${index}`;

  // Generate a stable ID based on object content and index
  const objString = typeof obj === "object" ? JSON.stringify(obj) : String(obj);
  return `row_${index}_${objString.slice(0, 20).replace(/[^a-zA-Z0-9]/g, "_")}`;
};

// ################################################################################################
export const ValueObjectGrid: FC<any> = (
  props: ValueObjectGridProps & { theme?: DeepPartial<TableTheme> }
) => {
  const renderStartTime = performance.now();
  const context = useMiroirContextService();
  const componentKey = `ValueObjectGrid-${
    props.mlSchema?.definition ? Object.keys(props.mlSchema.definition).join(",") : "unknown"
  }`;

  // log.info(":::::::::::::::::::::::::: ValueObjectGrid refreshing with props", props);

  // Get theme from context first, then allow prop overrides
  const contextTheme = useMiroirTableTheme();

  // Use the unified table theme with optional overrides
  // const tableTheme = useMemo(() => {
  //   return props.theme
  //     ? createTableTheme({
  //         ...contextTheme,
  //         ...props.theme,
  //       })
  //     : contextTheme;
  // }, [contextTheme, props.theme]);

  const filterToolbarStyles = useMemo(() => getFilterToolbarStyles(contextTheme), [contextTheme]);
  const agGridStyles = useMemo(() => generateAgGridStyles(contextTheme), [contextTheme]);
  const glideTheme = useMemo(() => generateGlideTheme(contextTheme), [contextTheme]);

  const gridApiRef = useRef<GridApi | null>(null);
  const [hasAnyFilter, setHasAnyFilter] = useState(false);

  // Dialog states for editing (only used when editing is enabled)
  const [dialogFormObject, setdialogFormObject] = useState<undefined | any>(undefined);
  const [editDialogFormIsOpen, setEditDialogFormIsOpen] = useState(false);
  const [deleteDialogFormIsOpen, setDeleteDialogFormIsOpen] = useState(false);

  // Container width tracking for adaptive column sizing
  // const containerRef = useRef<HTMLDivElement>(null);
  const [containerWidth, setContainerWidth] = useState<number>(1200);

  // ##############################################################################################
  // Auto-generate column definitions from mlSchema if not provided
  const autoGeneratedColumnDefs = useMemo(() => {
    return generateColumnDefsFromSchema(props.mlSchema);
  }, [props.mlSchema]);

  // Use provided columnDefs or auto-generated ones
  const effectiveColumnDefs: AutoGeneratedColumnDef[] = useMemo(() => {
    return props.columnDefs?.columnDefs || autoGeneratedColumnDefs;
  }, [props.columnDefs, autoGeneratedColumnDefs]);

  // ##############################################################################################
  // Transform value objects into grid rows (compatible with TableComponentRow)
  const valueObjectGridRows: { valueObjectGridRowSchema: ValueObjectGridRow[] } = useMemo(
    () => ({
      valueObjectGridRowSchema: (props.valueObjects || [])
        .sort((a: any, b: any) =>
          props.sortByAttribute
            ? a[props.sortByAttribute] > b[props.sortByAttribute]
              ? 1
              : a[props.sortByAttribute] < b[props.sortByAttribute]
              ? -1
              : 0
            : 0
        )
        .map((valueObject: any, index: number) => ({
          localId: generateLocalId(valueObject, index),
          rawValue: valueObject,
          mlSchema: props.mlSchema.definition || {},
          displayedValue: Object.fromEntries(
            Object.entries(valueObject).map(([key, value]) => {
              const fieldSchema = props.mlSchema.definition?.[key] as JzodElement;
              return [
                key,
                fieldSchema?.type === "object" || fieldSchema?.type === "array"
                  ? JSON.stringify(value)
                  : value,
              ];
            })
          ),
        })),
    }),
    [props.valueObjects, props.sortByAttribute, props.mlSchema]
  );

  // Convert to TableComponentRow format for compatibility with GlideDataGridComponent
  const tableComponentRows: { tableComponentRowUuidIndexSchema: any[] } = useMemo(
    () => ({
      tableComponentRowUuidIndexSchema: valueObjectGridRows.valueObjectGridRowSchema.map((row) => ({
        deploymentUuid: "", // Not needed for value objects
        rawValue: row.rawValue,
        mlSchema: row.mlSchema,
        foreignKeyObjects: {}, // Not needed for value objects
        displayedValue: row.displayedValue,
        localId: row.localId, // Keep localId for our own reference
      })),
    }),
    [valueObjectGridRows]
  );

  // ##############################################################################################
  // Grid event handlers
  // TODO: remove!!!
  const onGridReady = useCallback((params: any) => {
    gridApiRef.current = params.api;

    // Add custom filter handling similar to EntityInstanceGrid
    setTimeout(() => {
      const updateFilterUI = () => {
        const filterModel = gridApiRef.current?.getFilterModel();
        const hasAnyFilterActive = filterModel && Object.keys(filterModel).length > 0;
        setHasAnyFilter(!!hasAnyFilterActive);
      };

      updateFilterUI();

      if (gridApiRef.current) {
        gridApiRef.current.addEventListener("filterChanged", () => {
          setTimeout(updateFilterUI, 50);
        });
      }
    }, 100);
  }, []);

  const handleGlobalClearAllFilters = useCallback(() => {
    if (gridApiRef.current) {
      gridApiRef.current.setFilterModel(null);
      // log.info('All filters cleared in ValueObjectGrid');
    }
  }, []);

  // ##############################################################################################
  // Handle cell value changes (for display only, no actual editing)
  const onCellValueChanged = useCallback(async (event: CellValueChangedEvent) => {
    log.warn("onCellValueChanged in ValueObjectGrid - value objects are read-only", event);
  }, []);

  // ##############################################################################################
  // Handle cell clicks (no navigation for value objects)
  const onCellClicked = useCallback((event: CellClickedEvent) => {
    // log.info("ValueObjectGrid cell clicked", event.colDef.field, event.data);
    // Value objects don't have navigation behavior
  }, []);

  // ##############################################################################################
  // Dialog handlers (only used when editing is enabled via props)
  const handleEditDialogFormOpen = useCallback(
    (row?: ValueObjectGridRow, event?: any) => {
      if (!props.onRowEdit) return;

      // log.info('handleEditDialogFormOpen called with row', row);
      if (row) {
        setdialogFormObject(row.rawValue);
      } else {
        setdialogFormObject(undefined);
      }
      setEditDialogFormIsOpen(true);
    },
    [props.onRowEdit]
  );

  const handleEditDialogFormClose = useCallback((value?: string, event?: any) => {
    // log.info('handleEditDialogFormClose', value);
    setEditDialogFormIsOpen(false);
  }, []);

  const handleDeleteDialogFormOpen = useCallback(
    (row?: ValueObjectGridRow, event?: any) => {
      if (!props.onRowDelete) return;

      // log.info('handleDeleteDialogFormOpen called with row', row);
      if (row) {
        setdialogFormObject(row.rawValue);
      } else {
        setdialogFormObject(undefined);
      }
      setDeleteDialogFormIsOpen(true);
    },
    [props.onRowDelete]
  );

  const handleDuplicateDialogFormOpen = useCallback(
    (row?: ValueObjectGridRow, event?: any) => {
      if (!props.onRowDuplicate) return;

      // log.info('handleDuplicateDialogFormOpen called with row', row);
      if (row) {
        // Create a duplicate
        const duplicatedObject = { ...row.rawValue };
        setdialogFormObject(duplicatedObject);
      } else {
        setdialogFormObject(undefined);
      }
      setEditDialogFormIsOpen(true);
    },
    [props.onRowDuplicate]
  );

  const onEditDialogFormSubmit = useCallback(
    async (data: JsonObjectEditFormDialogInputs) => {
      // log.info('onEditDialogFormSubmit called with data', data);
      if (props.onRowEdit) {
        await props.onRowEdit(data);
      }
      handleEditDialogFormClose("");
    },
    [props.onRowEdit]
  );

  const onDeleteDialogFormSubmit = useCallback(
    async (data: JsonObjectEditFormDialogInputs) => {
      // log.info('onDeleteDialogFormSubmit called with data', data);
      if (props.onRowDelete) {
        await props.onRowDelete(data);
      }
      handleEditDialogFormClose("");
    },
    [props.onRowDelete]
  );


  // Define tools column configuration
  const toolsColumnDefinition: ToolsColumnDefinition = useMemo(
    () => ({
      field: "",
      headerName: "Actions",
      width: 120,
    }),
    []
  );

  // ##############################################################################################
  // Build column definitions with tools column if needed
  const columnDefs: (ColDef | ColGroupDef)[] = useMemo(() => {
    const baseColumnDefs = [];

    // Add tools column if editing is enabled
    if (props.displayTools && (props.onRowEdit || props.onRowDelete || props.onRowDuplicate)) {
      baseColumnDefs.push({
        field: toolsColumnDefinition.field,
        headerName: toolsColumnDefinition.headerName,
        cellRenderer: ToolsCellRenderer,
        editable: false,
        sortable: false,
        filter: false,
        resizable: false,
        width: toolsColumnDefinition.width,
        cellRendererParams: {
          onClickEdit: props.onRowEdit ? handleEditDialogFormOpen : undefined,
          onClickDuplicate: props.onRowDuplicate ? handleDuplicateDialogFormOpen : undefined,
          onClickDelete: props.onRowDelete ? handleDeleteDialogFormOpen : undefined,
        },
      });
    }

    // Add data columns
    const dataColumns = effectiveColumnDefs.map((colDef: any) => ({
      ...colDef,
      valueGetter: (params: any) => {
        if (!params.data || !colDef.field) return "";
        return (
          params.data.displayedValue?.[colDef.field] ?? params.data.rawValue?.[colDef.field] ?? ""
        );
      },
      filterValueGetter: (params: any) => {
        if (!params.data || !colDef.field) return "";
        return (
          params.data.displayedValue?.[colDef.field] ?? params.data.rawValue?.[colDef.field] ?? ""
        );
      },
      // filter: true,
      // filterParams: {
      //   filterOptions: ["contains", "startsWith", "endsWith", "equals", "notEqual"],
      //   defaultOption: "contains",
      //   suppressAndOrCondition: false,
      // },
    }));

    const allColumns = [...baseColumnDefs, ...dataColumns];

    return allColumns;
  }, [
    effectiveColumnDefs,
    props.displayTools,
    props.onRowEdit,
    props.onRowDelete,
    props.onRowDuplicate,
    handleEditDialogFormOpen,
    handleDuplicateDialogFormOpen,
    handleDeleteDialogFormOpen,
    // calculatedColumnWidths,
    toolsColumnDefinition,
  ]);

  // ##############################################################################################
  // Glide grid cell click handler
  const onGlideGridCellClicked = useCallback(
    (cell: any, event: any) => {
      const [col, row] = cell;
      const rowData = tableComponentRows.tableComponentRowUuidIndexSchema[row];
      // log.info("ValueObjectGrid Glide cell clicked", { col, row, rowData });
      // No navigation for value objects
    },
    [tableComponentRows]
  );

  // ##############################################################################################
  // Wrapper handlers to convert between TableComponentRow and ValueObjectGridRow
  const handleGlideEditDialogFormOpen = useCallback(
    (row: any, event?: any) => {
      if (!props.onRowEdit) return;
      // Find the original ValueObjectGridRow
      const originalRow = valueObjectGridRows.valueObjectGridRowSchema.find(
        (vRow) => vRow.localId === (row as any).localId
      );
      if (originalRow) {
        handleEditDialogFormOpen(originalRow, event);
      }
    },
    [props.onRowEdit, handleEditDialogFormOpen, valueObjectGridRows]
  );

  // ##############################################################################################
  const handleGlideDeleteDialogFormOpen = useCallback(
    (row: any, event?: any) => {
      if (!props.onRowDelete) return;
      const originalRow = valueObjectGridRows.valueObjectGridRowSchema.find(
        (vRow) => vRow.localId === (row as any).localId
      );
      if (originalRow) {
        handleDeleteDialogFormOpen(originalRow, event);
      }
    },
    [props.onRowDelete, handleDeleteDialogFormOpen, valueObjectGridRows]
  );

  // ##############################################################################################
  const handleGlideDuplicateDialogFormOpen = useCallback(
    (row: any, event?: any) => {
      if (!props.onRowDuplicate) return;
      const originalRow = valueObjectGridRows.valueObjectGridRowSchema.find(
        (vRow) => vRow.localId === (row as any).localId
      );
      if (originalRow) {
        handleDuplicateDialogFormOpen(originalRow, event);
      }
    },
    [props.onRowDuplicate, handleDuplicateDialogFormOpen, valueObjectGridRows]
  );

  // ##############################################################################################
  return (
    <div
      // ref={containerRef}
      style={{
        width: "100%",
        maxWidth: "100%",
        overflow: "hidden",
        boxSizing: "border-box",
        fontFamily: contextTheme.typography.fontFamily,
        position: "relative",
        zIndex: 1,
      }}
    >
      {/* Apply unified table styles */}
      <style>{agGridStyles}</style>

      {/* Global Clear All Filters Icon */}
      {hasAnyFilter && (
        <div style={filterToolbarStyles.container}>
          <span
            className="mtable-global-clear-filters"
            onClick={handleGlobalClearAllFilters}
            style={filterToolbarStyles.clearAllButton}
            title="Clear all filters"
          >
            â–¼ Clear All Filters
          </span>
        </div>
      )}

      {/* Grid implementation */}
      {props.gridType === "ag-grid" ? (
        <div
          id="valueObjectGrid"
          className="ag-theme-alpine"
          style={{
            ...(tableComponentRows.tableComponentRowUuidIndexSchema.length > 50
              ? {
                  ...props.styles,
                  height: "50vh",
                  maxHeight: contextTheme.components.table.maxHeight,
                }
              : {
                  ...props.styles,
                  minHeight: contextTheme.components.table.minHeight,
                }),
            width: "100%",
            maxWidth: "100%",
            overflow: "auto",
            boxSizing: "border-box",
            borderRadius: contextTheme.components.table.borderRadius,
            border: contextTheme.components.table.border,
          }}
        >
          <AgGridReact
            domLayout={
              tableComponentRows.tableComponentRowUuidIndexSchema.length > 50
                ? "normal"
                : "autoHeight"
            }
            columnDefs={columnDefs}
            rowData={tableComponentRows.tableComponentRowUuidIndexSchema}
            getRowId={(params) => {
              return (
                params.data?.localId || params.data?.rawValue?.uuid || Math.random().toString()
              );
            }}
            defaultColDef={defaultColDef}
            onCellClicked={onCellClicked}
            onCellValueChanged={onCellValueChanged}
            onGridReady={onGridReady}
            // enableRangeSelection={true}
            enableCellTextSelection={true}
            suppressRowClickSelection={true}
            animateRows={true}
            skipHeaderOnAutoSize={true}
            suppressHorizontalScroll={false}
            // rowSelection="multiple" // Enable multiple row selection for checkboxes
          />
        </div>
      ) : (
        <GlideDataGridComponent
          tableComponentRows={tableComponentRows}
          columnDefs={{ columnDefs: effectiveColumnDefs }}
          styles={{
            ...props.styles,
            fontFamily: contextTheme.typography.fontFamily,
            fontSize: contextTheme.typography.fontSize,
            borderRadius: contextTheme.components.table.borderRadius,
            border: contextTheme.components.table.border,
          }}
          type="JSON_ARRAY"
          // calculatedColumnWidths={calculatedColumnWidths}
          containerWidth={containerWidth}
          toolsColumnDefinition={toolsColumnDefinition}
          maxRows={props.maxRows}
          theme={contextTheme}
          glideTheme={glideTheme}
          onCellClicked={onGlideGridCellClicked}
          onCellEdited={(cell, newValue) => {
            log.info("ValueObjectGrid Glide cell edited (read-only)", cell, newValue);
          }}
          onRowEdit={props.onRowEdit ? handleGlideEditDialogFormOpen : undefined}
          onRowDelete={props.onRowDelete ? handleGlideDeleteDialogFormOpen : undefined}
          // onRowDuplicate={props.onRowDuplicate ? handleGlideDuplicateDialogFormOpen : undefined}
          onRowDuplicate={handleGlideDuplicateDialogFormOpen}
        />
      )}
    </div>
  );

  // Track render performance at end of render (ifThenElse)
  if (context.showPerformanceDisplay) {
    const renderEndTime = performance.now();
    const renderDuration = renderEndTime - renderStartTime;
    RenderPerformanceMetrics.trackRenderPerformance(componentKey, renderDuration);
  }
};
